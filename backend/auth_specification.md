# Authentication Flow

| Date       | Description                                |
| ---------- | ------------------------------------------ |
| 2026-02-14 | FEAT-USER-001: User Account Management     |

## 1. Overview

This document defines the authentication and authorization strategy for nihao-chat. It covers token management, password security, authentication flows, session lifecycle, and security mechanisms. The auth-service is the sole authority for authentication decisions; the gateway validates JWT access tokens for protected endpoints.

## 2. Token Strategy

### 2.1 Token Types

| Token          | Format | Storage              | TTL      | Purpose                                |
| -------------- | ------ | -------------------- | -------- | -------------------------------------- |
| Access Token   | JWT    | Client (memory/storage) | 15 min | Authenticate API requests              |
| Refresh Token  | JWT    | Redis (server-side)  | 7 days   | Obtain new access tokens without login |

### 2.2 Access Token Payload

```json
{
  "iss": "nihao-chat",
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "role": "user",
  "type": "access",
  "iat": 1700000000,
  "exp": 1700000900
}
```

| Field  | Type   | Description                       |
| ------ | ------ | --------------------------------- |
| `iss`  | string | Token issuer, always `nihao-chat` |
| `sub`  | string | User ID (UUID)                    |
| `role` | string | User role: `user` or `admin`      |
| `type` | string | Token type: `access`              |
| `iat`  | number | Issued at (Unix timestamp)        |
| `exp`  | number | Expiration (Unix timestamp)       |

### 2.3 Refresh Token Payload

```json
{
  "iss": "nihao-chat",
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "type": "refresh",
  "token_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "iat": 1700000000,
  "exp": 1700604800
}
```

| Field      | Type   | Description                                    |
| ---------- | ------ | ---------------------------------------------- |
| `iss`      | string | Token issuer, always `nihao-chat`              |
| `sub`      | string | User ID (UUID)                                 |
| `type`     | string | Token type: `refresh`                          |
| `token_id` | string | Unique token identifier for Redis lookup       |
| `iat`      | number | Issued at (Unix timestamp)                     |
| `exp`      | number | Expiration (Unix timestamp)                    |

### 2.4 Signing Configuration

| Parameter     | Value                |
| ------------- | -------------------- |
| Algorithm     | RS256                |
| Key type      | RSA 2048-bit         |
| Key rotation  | Every 90 days        |
| Key storage   | Environment variable / secrets manager |
| Issuer (`iss`)| `nihao-chat`         |

## 3. Password Security

### 3.1 Hashing Configuration

| Parameter   | Value         |
| ----------- | ------------- |
| Algorithm   | bcrypt        |
| Cost factor | 12            |
| Salt        | Auto-generated by bcrypt |

### 3.2 Password Rules

| Rule                     | Requirement                          |
| ------------------------ | ------------------------------------ |
| Minimum length           | 8 characters                         |
| Maximum length           | 72 characters (bcrypt 72-byte limit) |
| Uppercase letter         | At least 1 uppercase letter (A-Z)    |
| Lowercase letter         | At least 1 lowercase letter (a-z)    |
| Digit                    | At least 1 digit (0-9)               |

### 3.3 Validation Regex

```
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,72}$
```

## 4. Authentication Flows

### 4.1 Registration Flow

```mermaid
flowchart TD
    A[Client sends POST /auth/register/send-code] --> B[Gateway parses identifier_type]
    B --> C[auth-service receives SendVerificationCode]
    C --> D{Identifier already registered?}
    D -->|Yes| E[Return IDENTIFIER_ALREADY_EXISTS error]
    D -->|No| F[Generate 6-digit code]
    F --> G[Hash code with SHA-256 and store in Redis]
    G --> H[Publish to Kafka notification topic]
    H --> I[Return success to client]
    I --> J[Client receives code via email/SMS]
    J --> K[Client sends POST /auth/register]
    K --> L[auth-service validates code from Redis]
    L --> M{Code valid and not expired?}
    M -->|No| N[Return INVALID_VERIFICATION_CODE error]
    M -->|Yes| O[auth-service calls user-service CreateUser via gRPC]
    O --> P[user-service creates user + profile records]
    P --> Q[auth-service hashes password with bcrypt]
    Q --> R[auth-service stores credentials]
    R --> S[auth-service issues access + refresh tokens]
    S --> T[Store refresh token metadata in Redis]
    T --> U[Return tokens to client]
```

### 4.2 Login Flow (Email/Phone + Password)

```mermaid
flowchart TD
    A[Client sends POST /auth/login] --> B[Gateway parses identifier_type]
    B --> C[auth-service receives Login request]
    C --> D{Account locked?}
    D -->|Yes| E[Return ACCOUNT_LOCKED error]
    D -->|No| F[auth-service calls user-service GetUserByIdentifier]
    F --> G{User found?}
    G -->|No| H[Return INVALID_CREDENTIALS error]
    G -->|Yes| I[Fetch credentials from DB]
    I --> J{bcrypt verify password?}
    J -->|No| K[Increment failed attempts in Redis]
    K --> L{Attempts >= 5?}
    L -->|Yes| M[Set lockout key in Redis TTL 15min]
    M --> N[Return ACCOUNT_LOCKED error]
    L -->|No| O[Return INVALID_CREDENTIALS error]
    J -->|Yes| P[Clear failed attempts in Redis]
    P --> Q[Issue access + refresh tokens]
    Q --> R[Store refresh token metadata in Redis]
    R --> S[Return tokens to client]
```

### 4.3 Social Login Flow (Google/Apple)

```mermaid
flowchart TD
    A[Client sends POST /auth/login/google or /auth/login/apple] --> B[Gateway forwards to auth-service]
    B --> C[auth-service validates OAuth token with provider]
    C --> D{Token valid?}
    D -->|No| E[Return SOCIAL_AUTH_FAILED error]
    D -->|Yes| F{OAuth account exists in DB?}
    F -->|Yes| G[Retrieve user_id from oauth_accounts]
    G --> H[Issue access + refresh tokens]
    F -->|No| I{User with same email exists?}
    I -->|Yes| J[Link OAuth account to existing user]
    J --> H
    I -->|No| K[auth-service calls user-service CreateUser via gRPC]
    K --> L[Create oauth_accounts record]
    L --> H
    H --> M[Store refresh token metadata in Redis]
    M --> N[Return tokens to client]
```

### 4.4 Token Refresh Flow

```mermaid
flowchart TD
    A[Client sends POST /auth/token/refresh] --> B[Gateway forwards to auth-service]
    B --> C[auth-service decodes refresh token JWT]
    C --> D{JWT signature valid?}
    D -->|No| E[Return INVALID_TOKEN error]
    D -->|Yes| F{token_id exists in Redis?}
    F -->|No| G[Return INVALID_TOKEN error — token revoked]
    F -->|Yes| H[Delete old refresh token from Redis]
    H --> I[Issue new access + refresh tokens]
    I --> J[Store new refresh token metadata in Redis]
    J --> K[Return new tokens to client]
```

### 4.5 Logout Flow

```mermaid
flowchart TD
    A[Client sends POST /auth/logout] --> B[Gateway validates access token]
    B --> C[auth-service receives Logout request]
    C --> D[Delete refresh token from Redis by token_id]
    D --> E[Return success to client]
    E --> F[Client clears local token storage]
```

### 4.6 Change Password Flow

```mermaid
flowchart TD
    A[Client sends POST /auth/password/change] --> B[Gateway validates access token]
    B --> C[auth-service receives ChangePassword request]
    C --> D[Fetch credentials from DB by user_id]
    D --> E{bcrypt verify current password?}
    E -->|No| F[Return INVALID_CREDENTIALS error]
    E -->|Yes| G{New password meets rules?}
    G -->|No| H[Return WEAK_PASSWORD error]
    G -->|Yes| I[Hash new password with bcrypt]
    I --> J[Update credentials in DB]
    J --> K[Delete other refresh tokens from Redis — keep current session]
    K --> L[Return success to client]
```

### 4.7 Password Reset Flow

```mermaid
flowchart TD
    A[Client sends POST /auth/password/reset/send-code] --> B[Gateway parses identifier_type]
    B --> C[auth-service receives SendPasswordResetCode]
    C --> D{User exists with this identifier?}
    D -->|No| E[Return success silently — no user enumeration]
    D -->|Yes| F[Generate 6-digit code]
    F --> G[Hash code and store in Redis with purpose=password_reset]
    G --> H[Publish to Kafka notification topic]
    H --> I[Return success to client]
    I --> J[Client receives code via email/SMS]
    J --> K[Client sends POST /auth/password/reset]
    K --> L[auth-service validates code from Redis]
    L --> M{Code valid and not expired?}
    M -->|No| N[Return INVALID_VERIFICATION_CODE error]
    M -->|Yes| O{New password meets rules?}
    O -->|No| P[Return WEAK_PASSWORD error]
    O -->|Yes| Q[Hash new password with bcrypt]
    Q --> R[Update credentials in DB]
    R --> S[Delete ALL refresh tokens for user from Redis]
    S --> T[Return success to client]
```

## 5. Session Lifecycle Summary

```
Register/Login ──▶ Access Token (15min) + Refresh Token (7d)
       │
       ├──▶ API Request ──▶ Gateway validates access token
       │
       ├──▶ Access Token expires ──▶ Client calls /token/refresh
       │         │
       │         ├──▶ Valid refresh ──▶ New Access + Refresh tokens (rotation)
       │         └──▶ Invalid/expired ──▶ Client must re-login
       │
       ├──▶ Logout ──▶ Refresh token deleted from Redis
       │
       ├──▶ Change Password ──▶ OTHER refresh tokens deleted, current session kept
       │
       └──▶ Password Reset ──▶ ALL refresh tokens for user deleted from Redis
```

| Event            | Access Token State | Refresh Token State                |
| ---------------- | ------------------ | ---------------------------------- |
| Login/Register   | Issued (15 min)    | Issued and stored in Redis (7d)    |
| API Request      | Validated by gateway | Unchanged                        |
| Token Refresh    | New token issued   | Old deleted, new stored in Redis   |
| Logout           | Client discards    | Deleted from Redis                 |
| Change Password  | Unchanged          | Other tokens deleted, current kept |
| Password Reset   | Client discards    | All tokens for user deleted        |
| Token Expiry     | Rejected by gateway | Rejected by auth-service          |

## 6. Security Mechanisms

| Mechanism                  | Implementation                                                                                    |
| -------------------------- | ------------------------------------------------------------------------------------------------- |
| Account Lockout            | 5 consecutive failed login attempts → 15-minute lockout; tracked via Redis key `lockout:{identifier}` with TTL |
| Token Rotation             | Each refresh issues a new refresh token and invalidates the old one, preventing replay attacks     |
| Password Hashing           | bcrypt with cost factor 12; plaintext never stored or logged                                      |
| Short-Lived Access Tokens  | 15-minute TTL minimizes exposure window if token is intercepted                                   |
| Server-Side Refresh Tokens | Stored in Redis, not accessible to client after initial issuance; enables server-side revocation  |
| Mass Session Invalidation  | On password reset, all refresh tokens for the user are deleted from Redis; on password change, all other refresh tokens are deleted (current session kept) |
| Rate Limiting              | Gateway enforces per-endpoint, per-IP rate limits on sensitive endpoints                          |
| Verification Code Security | 6-digit codes hashed with SHA-256 before storage; 10-minute expiry; max 5 verification attempts  |
| User Enumeration Prevention| Password reset endpoint returns success regardless of whether the identifier exists               |
| Presigned Upload Security  | Avatar uploads use presigned POST with S3 policy enforcing 5 MB max and allowed MIME types        |
